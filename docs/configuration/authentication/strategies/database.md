# База данных

Самый естественный способ хранения токенов, конечно же, это использование той же самой базы данных, которую вы используете для своего приложения. В этой стратегии мы создаем таблицу (или коллекцию) для хранения этих токенов с соответствующим идентификатором пользователя. При каждом запросе мы пытаемся извлечь этот токен из базы данных, чтобы получить соответствующий идентификатор пользователя.

## Конфигурация

Конфигурация этой стратегии немного сложнее, чем у других, так как она требует настройки моделей и адаптера базы данных, [в точности так же, как мы делали для пользователей](../../overview.md#user-model-and-database-adapters).

### Адаптеры базы данных

Токен доступа будет структурирован следующим образом в вашей базе данных:

* `token` (`str`) – Уникальный идентификатор токена. Он генерируется автоматически при входе в систему с использованием этой стратегии.
* `user_id` (`ID`) – Идентификатор пользователя, связанного с этим токеном.
* `created_at` (`datetime`) – Дата и время создания токена. Используется для определения, истек ли срок действия токена или нет.

Мы предоставляем базовую модель с этими полями для каждой базы данных, которую мы поддерживаем.

#### SQLAlchemy

Мы расширим базовую конфигурацию SQLAlchemy.

```py hl_lines="5-8 23-24 45-48"
--8<-- "docs/src/db_sqlalchemy_access_tokens.py"
```

1. Мы определяем модель `AccessToken` ORM, унаследованную от `SQLAlchemyBaseAccessTokenTableUUID`.

2. Мы определяем зависимость для создания экземпляра класса `SQLAlchemyAccessTokenDatabase`. Как и адаптер базы данных пользователя, он ожидает свежую сессию SQLAlchemy и класс модели `AccessToken`, который мы определили выше.

!!! tip "Внешний ключ `user_id` определен как UUID"
    По умолчанию мы используем UUID в качестве первичного ключа ID для вашего пользователя, поэтому мы следуем тому же соглашению при определении внешнего ключа, указывающего на пользователя.

    Если вы хотите использовать другой тип, например, автоматически увеличиваемое целое число, вы можете использовать `SQLAlchemyBaseAccessTokenTable` в качестве базового класса и определить свой собственный столбец `user_id`.

    ```py
    class AccessToken(SQLAlchemyBaseAccessTokenTable[int], Base):
        @declared_attr
        def user_id(cls) -> Mapped[int]:
            return mapped_column(Integer, ForeignKey("user.id", ondelete="cascade"), nullable=False)
    ```

    Обратите внимание, что `SQLAlchemyBaseAccessTokenTable` ожидает обобщенный тип, чтобы определить фактический тип ID, который вы используете.

#### Beanie

Мы расширим базовую конфигурацию Beanie.

```py hl_lines="4-7 20-21 28-29"
--8<-- "docs/src/db_beanie_access_tokens.py"
```

1. Мы определяем модель `AccessToken` ODM, унаследованную от `BeanieBaseAccessToken`. Обратите внимание, что мы устанавливаем обобщенный тип для определения типа ссылки `user_id`. По умолчанию это стандартный ObjectID MongoDB.

2. Мы определяем зависимость для создания экземпляра класса `BeanieAccessTokenDatabase`. Как и адаптер базы данных пользователя, он ожидает класс модели `AccessToken`, который мы определили выше.

Не забудьте добавить модель `AccessToken` ODM в массив `document_models` при инициализации Beanie, [как вы это сделали с моделью `User`](../../databases/beanie.md#initialize-beanie)!

!!! info
    Если вы хотите добавить свои собственные настройки для вашей модели документа `AccessToken`, например, изменить имя коллекции, не забудьте позволить вашему внутреннему классу `Settings` наследовать предопределенные настройки от `BeanieBaseAccessToken`, например так: `Settings(BeanieBaseAccessToken.Settings): # ...`! См. документацию Beanie по [`Settings`](https://beanie-odm.dev/tutorial/defining-a-document/#settings) для получения дополнительной информации.

### Стратегия

```py
import uuid

from fastapi import Depends
from fastapi_users.authentication.strategy.db import AccessTokenDatabase, DatabaseStrategy

from .db import AccessToken, User


def get_database_strategy(
    access_token_db: AccessTokenDatabase[AccessToken] = Depends(get_access_token_db),
) -> DatabaseStrategy:
    return DatabaseStrategy(access_token_db, lifetime_seconds=3600)
```

Как видите, создание экземпляра довольно просто. Он принимает следующие аргументы:

* `database` (`AccessTokenDatabase`): Экземпляр адаптера базы данных для таблицы `AccessToken`, как мы определили выше.
* `lifetime_seconds` (`int`): Срок действия токена в секундах.

!!! tip "Почему это внутри функции?"
    Чтобы стратегии можно было создавать динамически с другими зависимостями, они должны предоставляться как вызываемые функции для аутентификационного бэкенда.

    Как видите здесь, такой подход позволяет динамически в

недрять подключение к базе данных.

## Выход из системы

При выходе из системы эта стратегия удалит токен из базы данных.